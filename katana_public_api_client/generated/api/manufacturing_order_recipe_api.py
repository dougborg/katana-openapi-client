"""
Katana Public API

Public API for Katana Manufacturing Resource Planning (MRP) platform.  This OpenAPI specification provides comprehensive access to Katana's manufacturing, inventory, sales, and purchasing capabilities.  **Key Features:** - Complete CRUD operations for all business objects - Real-time inventory management and tracking - Manufacturing order and BOM (Bill of Materials) management - Sales and purchase order processing - Webhook event notifications for real-time integrations - Rate limiting with retry headers for reliable API usage - Comprehensive pagination support for list endpoints  **API Limits:** - Rate limit: 60 requests per 60 seconds - Max page size: 250 records per request - Default page size: 50 records per request  **Webhook Events:** Subscribe to real-time notifications for 50+ event types including sales orders, manufacturing orders, inventory changes, and more.

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import re  # noqa: F401
from datetime import datetime
from typing import Annotated

from pydantic import (
    Field,
    StrictBool,
    StrictFloat,
    StrictInt,
    StrictStr,
    conlist,
    validate_arguments,
)

from katana_public_api_client.generated.api_client import ApiClient
from katana_public_api_client.generated.api_response import ApiResponse
from katana_public_api_client.generated.errors import (  # noqa: F401
    ApiTypeError,
    ApiValueError,
)
from katana_public_api_client.generated.models.create_manufacturing_order_recipe_row_request import (
    CreateManufacturingOrderRecipeRowRequest,
)
from katana_public_api_client.generated.models.error_response import ErrorResponse
from katana_public_api_client.generated.models.manufacturing_order_recipe_row import (
    ManufacturingOrderRecipeRow,
)
from katana_public_api_client.generated.models.manufacturing_order_recipe_row_list_response import (
    ManufacturingOrderRecipeRowListResponse,
)
from katana_public_api_client.generated.models.update_manufacturing_order_recipe_row_request import (
    UpdateManufacturingOrderRecipeRowRequest,
)


class ManufacturingOrderRecipeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    async def create_manufacturing_order_recipe_rows(
        self,
        create_manufacturing_order_recipe_row_request: Annotated[
            CreateManufacturingOrderRecipeRowRequest,
            Field(..., description="new manufacturing order recipe details"),
        ],
        **kwargs,
    ) -> ManufacturingOrderRecipeRow:
        """Create a manufacturing order recipe row  # noqa: E501

        Add a recipe row to an existing manufacturing order.   Recipe rows cannot be added when the manufacturing order status is DONE.  # noqa: E501

        :param create_manufacturing_order_recipe_row_request: new manufacturing order recipe details (required)
        :type create_manufacturing_order_recipe_row_request: CreateManufacturingOrderRecipeRowRequest
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManufacturingOrderRecipeRow
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the create_manufacturing_order_recipe_rows_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            raise ValueError(message)
        return await self.create_manufacturing_order_recipe_rows_with_http_info(
            create_manufacturing_order_recipe_row_request, **kwargs
        )

    @validate_arguments
    async def create_manufacturing_order_recipe_rows_with_http_info(
        self,
        create_manufacturing_order_recipe_row_request: Annotated[
            CreateManufacturingOrderRecipeRowRequest,
            Field(..., description="new manufacturing order recipe details"),
        ],
        **kwargs,
    ) -> ApiResponse:
        """Create a manufacturing order recipe row  # noqa: E501

        Add a recipe row to an existing manufacturing order.   Recipe rows cannot be added when the manufacturing order status is DONE.  # noqa: E501

        :param create_manufacturing_order_recipe_row_request: new manufacturing order recipe details (required)
        :type create_manufacturing_order_recipe_row_request: CreateManufacturingOrderRecipeRowRequest
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManufacturingOrderRecipeRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["create_manufacturing_order_recipe_row_request"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_manufacturing_order_recipe_rows" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_manufacturing_order_recipe_row_request"] is not None:
            _body_params = _params["create_manufacturing_order_recipe_row_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["bearerAuth"]

        _response_types_map = {
            "200": "ManufacturingOrderRecipeRow",
            "401": "ErrorResponse",
            "429": "ErrorResponse",
            "500": "ErrorResponse",
        }

        return await self.api_client.call_api(
            "/manufacturing_order_recipe_rows",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def delete_manufacturing_order_recipe_row(
        self,
        id: Annotated[
            StrictInt, Field(..., description="Manufacturing order recipe id")
        ],
        **kwargs,
    ) -> ErrorResponse:
        """Delete a manufacturing order recipe row  # noqa: E501

        Deletes a single manufacturing order recipe row by id.  # noqa: E501

        :param id: Manufacturing order recipe id (required)
        :type id: int
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ErrorResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the delete_manufacturing_order_recipe_row_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            raise ValueError(message)
        return await self.delete_manufacturing_order_recipe_row_with_http_info(
            id, **kwargs
        )

    @validate_arguments
    async def delete_manufacturing_order_recipe_row_with_http_info(
        self,
        id: Annotated[
            StrictInt, Field(..., description="Manufacturing order recipe id")
        ],
        **kwargs,
    ) -> ApiResponse:
        """Delete a manufacturing order recipe row  # noqa: E501

        Deletes a single manufacturing order recipe row by id.  # noqa: E501

        :param id: Manufacturing order recipe id (required)
        :type id: int
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ErrorResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_manufacturing_order_recipe_row" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["id"] is not None:
            _path_params["id"] = _params["id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings = ["bearerAuth"]

        _response_types_map = {
            "204": "ErrorResponse",
            "401": "ErrorResponse",
            "404": "ErrorResponse",
            "429": "ErrorResponse",
            "500": "ErrorResponse",
        }

        return await self.api_client.call_api(
            "/manufacturing_order_recipe_rows/{id}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_all_manufacturing_order_recipe_rows(
        self,
        ids: Annotated[
            conlist(StrictInt) | None,
            Field(description="Filters results by an array of IDs."),
        ] = None,
        manufacturing_order_id: Annotated[
            StrictFloat | StrictInt | None,
            Field(description="Filters manufacturing orders by location."),
        ] = None,
        variant_id: Annotated[
            StrictInt | None,
            Field(description="Filters results by a valid variant id."),
        ] = None,
        ingredient_availability: Annotated[
            StrictStr | None,
            Field(
                description="Filters manufacturing orders by an ingredient availability."
            ),
        ] = None,
        include_deleted: Annotated[
            StrictBool | None, Field(description="Include soft-deleted items.")
        ] = None,
        limit: Annotated[
            StrictInt | None,
            Field(description="Number of records to return per page."),
        ] = None,
        page: Annotated[
            StrictInt | None, Field(description="Page number to return.")
        ] = None,
        created_at_min: Annotated[
            datetime | None,
            Field(description="Minimum creation date (ISO 8601 format)."),
        ] = None,
        created_at_max: Annotated[
            datetime | None,
            Field(description="Maximum creation date (ISO 8601 format)."),
        ] = None,
        updated_at_min: Annotated[
            datetime | None,
            Field(description="Minimum update date (ISO 8601 format)."),
        ] = None,
        updated_at_max: Annotated[
            datetime | None,
            Field(description="Maximum update date (ISO 8601 format)."),
        ] = None,
        **kwargs,
    ) -> ManufacturingOrderRecipeRowListResponse:
        """List all manufacturing order recipe rows  # noqa: E501

        Returns a list of manufacturing order recipe rows you've previously created. The manufacturing order   recipe rows are returned in sorted order, with the most recent manufacturing order recipe rows appearing first.  # noqa: E501

        :param ids: Filters results by an array of IDs.
        :type ids: List[int]
        :param manufacturing_order_id: Filters manufacturing orders by location.
        :type manufacturing_order_id: float
        :param variant_id: Filters results by a valid variant id.
        :type variant_id: int
        :param ingredient_availability: Filters manufacturing orders by an ingredient availability.
        :type ingredient_availability: str
        :param include_deleted: Include soft-deleted items.
        :type include_deleted: bool
        :param limit: Number of records to return per page.
        :type limit: int
        :param page: Page number to return.
        :type page: int
        :param created_at_min: Minimum creation date (ISO 8601 format).
        :type created_at_min: datetime
        :param created_at_max: Maximum creation date (ISO 8601 format).
        :type created_at_max: datetime
        :param updated_at_min: Minimum update date (ISO 8601 format).
        :type updated_at_min: datetime
        :param updated_at_max: Maximum update date (ISO 8601 format).
        :type updated_at_max: datetime
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManufacturingOrderRecipeRowListResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_all_manufacturing_order_recipe_rows_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            raise ValueError(message)
        return await self.get_all_manufacturing_order_recipe_rows_with_http_info(
            ids,
            manufacturing_order_id,
            variant_id,
            ingredient_availability,
            include_deleted,
            limit,
            page,
            created_at_min,
            created_at_max,
            updated_at_min,
            updated_at_max,
            **kwargs,
        )

    @validate_arguments
    async def get_all_manufacturing_order_recipe_rows_with_http_info(
        self,
        ids: Annotated[
            conlist(StrictInt) | None,
            Field(description="Filters results by an array of IDs."),
        ] = None,
        manufacturing_order_id: Annotated[
            StrictFloat | StrictInt | None,
            Field(description="Filters manufacturing orders by location."),
        ] = None,
        variant_id: Annotated[
            StrictInt | None,
            Field(description="Filters results by a valid variant id."),
        ] = None,
        ingredient_availability: Annotated[
            StrictStr | None,
            Field(
                description="Filters manufacturing orders by an ingredient availability."
            ),
        ] = None,
        include_deleted: Annotated[
            StrictBool | None, Field(description="Include soft-deleted items.")
        ] = None,
        limit: Annotated[
            StrictInt | None,
            Field(description="Number of records to return per page."),
        ] = None,
        page: Annotated[
            StrictInt | None, Field(description="Page number to return.")
        ] = None,
        created_at_min: Annotated[
            datetime | None,
            Field(description="Minimum creation date (ISO 8601 format)."),
        ] = None,
        created_at_max: Annotated[
            datetime | None,
            Field(description="Maximum creation date (ISO 8601 format)."),
        ] = None,
        updated_at_min: Annotated[
            datetime | None,
            Field(description="Minimum update date (ISO 8601 format)."),
        ] = None,
        updated_at_max: Annotated[
            datetime | None,
            Field(description="Maximum update date (ISO 8601 format)."),
        ] = None,
        **kwargs,
    ) -> ApiResponse:
        """List all manufacturing order recipe rows  # noqa: E501

        Returns a list of manufacturing order recipe rows you've previously created. The manufacturing order   recipe rows are returned in sorted order, with the most recent manufacturing order recipe rows appearing first.  # noqa: E501

        :param ids: Filters results by an array of IDs.
        :type ids: List[int]
        :param manufacturing_order_id: Filters manufacturing orders by location.
        :type manufacturing_order_id: float
        :param variant_id: Filters results by a valid variant id.
        :type variant_id: int
        :param ingredient_availability: Filters manufacturing orders by an ingredient availability.
        :type ingredient_availability: str
        :param include_deleted: Include soft-deleted items.
        :type include_deleted: bool
        :param limit: Number of records to return per page.
        :type limit: int
        :param page: Page number to return.
        :type page: int
        :param created_at_min: Minimum creation date (ISO 8601 format).
        :type created_at_min: datetime
        :param created_at_max: Maximum creation date (ISO 8601 format).
        :type created_at_max: datetime
        :param updated_at_min: Minimum update date (ISO 8601 format).
        :type updated_at_min: datetime
        :param updated_at_max: Maximum update date (ISO 8601 format).
        :type updated_at_max: datetime
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManufacturingOrderRecipeRowListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "ids",
            "manufacturing_order_id",
            "variant_id",
            "ingredient_availability",
            "include_deleted",
            "limit",
            "page",
            "created_at_min",
            "created_at_max",
            "updated_at_min",
            "updated_at_max",
        ]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_manufacturing_order_recipe_rows" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("ids") is not None:
            _query_params.append(("ids", _params["ids"]))
            _collection_formats["ids"] = "multi"

        if _params.get("manufacturing_order_id") is not None:
            _query_params.append(
                ("manufacturing_order_id", _params["manufacturing_order_id"])
            )

        if _params.get("variant_id") is not None:
            _query_params.append(("variant_id", _params["variant_id"]))

        if _params.get("ingredient_availability") is not None:
            _query_params.append(
                ("ingredient_availability", _params["ingredient_availability"])
            )

        if _params.get("include_deleted") is not None:
            _query_params.append(("include_deleted", _params["include_deleted"]))

        if _params.get("limit") is not None:
            _query_params.append(("limit", _params["limit"]))

        if _params.get("page") is not None:
            _query_params.append(("page", _params["page"]))

        if _params.get("created_at_min") is not None:
            if isinstance(_params["created_at_min"], datetime):
                _query_params.append(
                    (
                        "created_at_min",
                        _params["created_at_min"].strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_at_min", _params["created_at_min"]))

        if _params.get("created_at_max") is not None:
            if isinstance(_params["created_at_max"], datetime):
                _query_params.append(
                    (
                        "created_at_max",
                        _params["created_at_max"].strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("created_at_max", _params["created_at_max"]))

        if _params.get("updated_at_min") is not None:
            if isinstance(_params["updated_at_min"], datetime):
                _query_params.append(
                    (
                        "updated_at_min",
                        _params["updated_at_min"].strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("updated_at_min", _params["updated_at_min"]))

        if _params.get("updated_at_max") is not None:
            if isinstance(_params["updated_at_max"], datetime):
                _query_params.append(
                    (
                        "updated_at_max",
                        _params["updated_at_max"].strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("updated_at_max", _params["updated_at_max"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings = ["bearerAuth"]

        _response_types_map = {
            "200": "ManufacturingOrderRecipeRowListResponse",
            "401": "ErrorResponse",
            "429": "ErrorResponse",
            "500": "ErrorResponse",
        }

        return await self.api_client.call_api(
            "/manufacturing_order_recipe_rows",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def get_manufacturing_order_recipe_row(
        self,
        id: Annotated[
            StrictFloat | StrictInt,
            Field(..., description="Manufacturing order recipe row id"),
        ],
        **kwargs,
    ) -> ManufacturingOrderRecipeRow:
        """Retrieve a manufacturing order recipe row  # noqa: E501

        Retrieves the details of an existing manufacturing order recipe row.  # noqa: E501

        :param id: Manufacturing order recipe row id (required)
        :type id: float
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManufacturingOrderRecipeRow
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the get_manufacturing_order_recipe_row_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            raise ValueError(message)
        return await self.get_manufacturing_order_recipe_row_with_http_info(
            id, **kwargs
        )

    @validate_arguments
    async def get_manufacturing_order_recipe_row_with_http_info(
        self,
        id: Annotated[
            StrictFloat | StrictInt,
            Field(..., description="Manufacturing order recipe row id"),
        ],
        **kwargs,
    ) -> ApiResponse:
        """Retrieve a manufacturing order recipe row  # noqa: E501

        Retrieves the details of an existing manufacturing order recipe row.  # noqa: E501

        :param id: Manufacturing order recipe row id (required)
        :type id: float
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManufacturingOrderRecipeRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["id"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manufacturing_order_recipe_row" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["id"] is not None:
            _path_params["id"] = _params["id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # authentication setting
        _auth_settings = ["bearerAuth"]

        _response_types_map = {
            "200": "ManufacturingOrderRecipeRow",
            "401": "ErrorResponse",
            "429": "ErrorResponse",
            "500": "ErrorResponse",
        }

        return await self.api_client.call_api(
            "/manufacturing_order_recipe_rows/{id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    async def update_manufacturing_order_recipe_rows(
        self,
        id: Annotated[
            StrictInt, Field(..., description="manufacturing order recipe id")
        ],
        update_manufacturing_order_recipe_row_request: Annotated[
            UpdateManufacturingOrderRecipeRowRequest,
            Field(..., description="manufacturing order recipe details"),
        ],
        **kwargs,
    ) -> ManufacturingOrderRecipeRow:
        """Update a manufacturing order recipe row  # noqa: E501

        Updates the specified manufacturing order recipe row by setting the values of the parameters passed.   Any parameters not provided will be left unchanged. Recipe rows cannot be updated when   the manufacturing order status is DONE.  # noqa: E501

        :param id: manufacturing order recipe id (required)
        :type id: int
        :param update_manufacturing_order_recipe_row_request: manufacturing order recipe details (required)
        :type update_manufacturing_order_recipe_row_request: UpdateManufacturingOrderRecipeRowRequest
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ManufacturingOrderRecipeRow
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            message = "Error! Please call the update_manufacturing_order_recipe_rows_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            raise ValueError(message)
        return await self.update_manufacturing_order_recipe_rows_with_http_info(
            id, update_manufacturing_order_recipe_row_request, **kwargs
        )

    @validate_arguments
    async def update_manufacturing_order_recipe_rows_with_http_info(
        self,
        id: Annotated[
            StrictInt, Field(..., description="manufacturing order recipe id")
        ],
        update_manufacturing_order_recipe_row_request: Annotated[
            UpdateManufacturingOrderRecipeRowRequest,
            Field(..., description="manufacturing order recipe details"),
        ],
        **kwargs,
    ) -> ApiResponse:
        """Update a manufacturing order recipe row  # noqa: E501

        Updates the specified manufacturing order recipe row by setting the values of the parameters passed.   Any parameters not provided will be left unchanged. Recipe rows cannot be updated when   the manufacturing order status is DONE.  # noqa: E501

        :param id: manufacturing order recipe id (required)
        :type id: int
        :param update_manufacturing_order_recipe_row_request: manufacturing order recipe details (required)
        :type update_manufacturing_order_recipe_row_request: UpdateManufacturingOrderRecipeRowRequest
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ManufacturingOrderRecipeRow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["id", "update_manufacturing_order_recipe_row_request"]
        _all_params.extend(
            [
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_manufacturing_order_recipe_rows" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["id"] is not None:
            _path_params["id"] = _params["id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["update_manufacturing_order_recipe_row_request"] is not None:
            _body_params = _params["update_manufacturing_order_recipe_row_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["bearerAuth"]

        _response_types_map = {
            "200": "ManufacturingOrderRecipeRow",
            "401": "ErrorResponse",
            "429": "ErrorResponse",
            "500": "ErrorResponse",
        }

        return await self.api_client.call_api(
            "/manufacturing_order_recipe_rows/{id}",
            "PATCH",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get("_return_http_data_only"),
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
